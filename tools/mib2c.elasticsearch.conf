## ########################################################################
##
## Gotchas.
## Any $ signs in the output will be snaffled and disappear. For this reason
## lines that need to output perl variables use a printf line instead, note
## that the '$' sign is passed in via a '%s' format conversion.
##
## Comments that are for the use of documenting this config file
## need to be double hashes
##
## #########################################################################


## #########################################################################
## Define the 'macros' used later in this config file
## #########################################################################
@define EMIT_INDEX_VARS@
  ##
  ## Calculate the number of index identifiers and then
  ## for each identifier work out the offset in the oid
  ##
  @eval $numindex=0@
  @eval $idxoffset = $c.oidlength@
  # The values of the oid elements for the indexes
  @foreach $i index@
##  my $$idx_$i = getOidElement($$idx, $idxoffset);
  @printf "  my %sidx_$vars{'i'} = getOidElement(%soid, $vars{'idxoffset'});\n",$,$@
     @eval $idxoffset = $idxoffset + 1@
  @end@
@enddefine@

@define EMIT_GETARGS@
  ##
  ## Output the code the get the args for a function
  ##
  # The OID is passed as a NetSNMP::OID object
  @printf "  my (%soid) = shift;\n",$@
@enddefine@

@define EMIT_LOAD_DATA@
  ## 
  ## Emit the code to load a data table
  ##
  # Load the $t table data
  load_$t();
@enddefine@

@define EMIT_INDEX_INFO@
##
## Emit a list of indexes for a table as perl comments
## To be used when generating the comment fields for a handler
##
# In Table: $t
@foreach $i index@
# Index: $i
@end@
@enddefine@

@define EMIT_INDEX_WALKER@
##
## Output a skeleton index walker and index checker
## for the table if it has not been done already
##
@if $needwalker@
## Output skeleton index validator for table
# -------------------------------------------------------
# Index validation for table $t
# Checks the supplied OID is in range
# Returns 1 if it is and 0 if out of range
@calldefine EMIT_INDEX_INFO@
# -------------------------------------------------------
sub check_$t {
  @calldefine EMIT_GETARGS@

  @calldefine EMIT_INDEX_VARS@

  @calldefine EMIT_LOAD_DATA@

  # Check the index is in range and valid
  return 1;
}

# -------------------------------------------------------
# Index walker for table $t
# Given an OID for a table, returns the next OID in range, 
# or if no more OIDs it returns 0.
@calldefine EMIT_INDEX_INFO@
# -------------------------------------------------------
sub next_$t {
  @calldefine EMIT_GETARGS@

  @calldefine EMIT_INDEX_VARS@

  @calldefine EMIT_LOAD_DATA@

  # Return the next OID if there is one
  # or return 0 if no more OIDs in this table
  return 0;
}
@eval $needwalker = 0@    ## Dont need this again for the current table
@end@
@enddefine@

@define EMIT_TABLE_LOAD@
# -------------------------------------------------------
# Loader for table $t
# Edit this function to load the data needed for $t
# This function gets called for every request to columnar
# data in the $t table
# -------------------------------------------------------
sub load_$t { 
  
}  
@enddefine@

@eval $date=scalar localtime; @

## Start writing the template files

@open oidmap.pm@
#!/usr/bin/perl -w
#
# This file has been generated by mib2c using the mib2c.elasticsearch.conf
# file.
#
# Created on $date
##
## Create the skeleton file ready for the skeleton handlers later on
## Generate the hash of hashes with the oids and handlers for the tables

# The base OID for zalEs
@printf "our %sbase = '$oid';\n",$@

# Hash of all OIDs
our %oidmap = (
  #
  # Table objects
@foreach $t table@
  @print Processing table $t@
  @foreach $idx index@    
    @printf "  %s => {\n    name => '%s',\n    oid => '%s',\n    jref => '%s%s',\n    parent => '%s',\n    index => '1',\n  },\n",$idx.parent,$idx,$idx.objectID,$,$idx.description,$t@
  @end@
  @foreach $nidx nonindex@    
    @if $nidx.accessible @
      @printf "  %s => {\n    type => %s,\n    jref => '%s',\n    oid => '%s',\n    parent => '%s',\n    table_entry => 1,\n  },\n",$nidx,$nidx.type,$nidx.description,$nidx.objectID,$nidx.parent@
    @end@
  @end@
@end@
@print Processing scalars@
## output the hash with the OIDs and handlers
## Scalars have a single index element
  #
  # Scalars
@foreach $s scalar@
 @if $s.accessible@
    @printf "  %s => {\n    type => %s,\n    jref => '%s%s',\n    oid => '%s',\n  },\n",$s,$s.type,$,$s.description,$s.objectID@
 @end@
@end@
##End of the OID hash
);

1;
@close oidmap.pm@

@print Output code generated.@

